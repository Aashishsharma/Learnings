## Index
1. **Searching** - Sequential, binary(sorted - log n), fibonacci (if non-uniform memory access, then beneficial over binary)
2. **Time complexity** - for input I1 time taken T1, for I2-T2, draw graph, creat equation, keep only highest term, that is complexity
3. **Internal(all data in memory)** - 1. Insertion(insertion(next elem from unsorted sub array to it's correct pos. in sorted sub-arr, **O(n2)**), shell(n elems split in k segments, sort arr[i] with arr[k+i], then k=k/2, **O(n1.25)**)), 2. Selection(selection (smallest elem from unsorted sub arr added at last in sorted sub arr, **O(n2)**), heap (from geap, remove root, replace last elem from heap to root, then re-heap, **O(n logn)**)) - 3. Exchange( every sort does exchange, but these sorts do it extensively, bubble (from last to i, while last>i, exchange last with last-1, then last=last, i++ **O(n2)**), quick(1st elem = pivot, do 2 traversals, from left find 1st elem > pivot, from right ast elem < pivot, replace those 2 elems wile left < right, no replace pivot with left(all elems left of pivot are < pivot and on right > pivot), repeat, **O(n logn)**)), 4. Merge (merge each pair of elems, then merge quadraplets, then octaplates, n so on, **O(n logn)**), 5. Radix - (for alphabets, pockets = 26, for nos, p = 10, find largest elem in array, len = length of largest elem, while i < len, while j < last put no in LSBth pocket, after paas 1 remove elems from 0 to nth packet sequentially, continue till i < len, **O(n logn)**)
4. **External(not all in mem)** - 1. Natural, 2. Polyphase, 3. Balanced