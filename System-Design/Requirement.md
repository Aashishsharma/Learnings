# Unerstanding requirements

Understanding Requirements:

Functional Requirements:
Identifying core features
User stories
Non-functional Requirements:
Performance
Scalability
Reliability
Security
Architecture Patterns:

Client-Server Architecture:
Distributed systems
Load balancing
Microservices Architecture:
Service decomposition
Inter-service communication
Deployment strategies
Event-Driven Architecture:
Pub/Sub model
Event sourcing
CQRS (Command Query Responsibility Segregation)
Database Design:

Relational Databases:
Entity-Relationship Modeling (ERD)
Normalization
Indexing
NoSQL Databases:
Document-oriented databases
Key-value stores
Graph databases
Scalability and Performance:

Horizontal Scaling:
Load balancing
Sharding
Vertical Scaling:
Increasing resources (CPU, RAM)
Database optimization techniques
Caching:
CDN caching
In-memory caching (e.g., Redis)
System Design Tools and Techniques:

UML (Unified Modeling Language):
Use case diagrams
Class diagrams
Sequence diagrams
Design Patterns:
Creational, Structural, and Behavioral patterns
Singleton, Factory, Observer, etc.
API Design:

RESTful APIs:
Resource modeling
HTTP methods
Authentication and authorization
GraphQL:
Query language
Schema design
Resolver functions
Security:

Authentication and Authorization:
JWT (JSON Web Tokens)
OAuth
Role-based access control (RBAC)
Data Encryption:
TLS/SSL
Encryption algorithms
Data masking
Fault Tolerance and Reliability:

Redundancy:
Replication
Failover
Monitoring and Alerting:
Health checks
Logging
Metrics collection
Deployment and Infrastructure:

Cloud Services:
AWS, Azure, Google Cloud
Infrastructure as Code (IaC)
Containerization:
Docker
Kubernetes
Continuous Integration/Continuous Deployment (CI/CD):
Jenkins, GitLab CI/CD, CircleCI
Performance Optimization:

Database Optimization:
Query optimization
Index optimization
Caching Strategies:
CDN caching
In-memory caching (e.g., Redis)
Content Delivery Networks (CDNs):
Content caching
Edge computing